 works but follow each waypoint (too slow)
 def find_next_waypoint(self, x, y):
        closest_idx = self.find_closest_waypoint(x, y)
        region_of_acceptance = 0.05
        dist_to_waypoint = np.linalg.norm([x - self.waypoints_x[closest_idx], y - self.waypoints_y[closest_idx]])

        if abs(closest_idx - self.last_waypoint_index) > 3:
            self.last_waypoint_index += 1
            print("here: ", closest_idx - self.last_waypoint_index)
            target_idx = self.last_waypoint_index
        else:
            if dist_to_waypoint < region_of_acceptance and closest_idx >= self.last_waypoint_index:
                    self.last_waypoint_index = closest_idx + 1

            target_idx = max(self.last_waypoint_index, closest_idx)
        return min(target_idx, len(self.waypoints_x) - 1)

v2: works but not very well (goes back a bit)
def find_next_waypoint(self, x, y):
        closest_idx = self.find_closest_waypoint(x, y)
        region_of_acceptance = 0.05
        dist_to_waypoint = np.linalg.norm([x - self.waypoints_x[closest_idx], y - self.waypoints_y[closest_idx]])
    
        if dist_to_waypoint < region_of_acceptance and closest_idx >= self.last_waypoint_index:
            if abs(closest_idx - self.last_waypoint_index) > 3:
                self.last_waypoint_index += 1
            else:
                self.last_waypoint_index = closest_idx + 1

        target_idx = max(self.last_waypoint_index, closest_idx)
        return min(target_idx, len(self.waypoints_x) - 1)

v3: works but not when speed is increased:
# Ensuring we always moving forward in the waypoint list
        if dist_to_waypoint < region_of_acceptance:
            self.last_waypoint_index = max(self.last_waypoint_index, closest_idx)
        else:
            # If the vehicle is not within the region of acceptance of the closest waypoint,
            # check a few waypoints ahead to avoid being stuck in local minimum
            lookahead_idx = min(closest_idx + 3, len(self.waypoints_x) - 1)
            for i in range(closest_idx + 1, lookahead_idx + 1):
                dist_to_waypoint = np.linalg.norm([x - self.waypoints_x[i], y - self.waypoints_y[i]])
                if dist_to_waypoint < region_of_acceptance:
                    self.last_waypoint_index = max(self.last_waypoint_index, i)
                    break

V4: best yet


V5:
def find_next_waypoint(self, x, y):
        closest_idx, dist_to_waypoint = self.find_closest_waypoint(x, y)
        region_of_acceptance = 0.05
        max_idx_jump = 5
        look_ahead_range = 5

        # Check waypoints in the vicinity of the closest waypoint to find the best next waypoint
        start_idx = max(self.last_waypoint_index, closest_idx - look_ahead_range)
        end_idx = min(len(self.waypoints_x) - 1, closest_idx + look_ahead_range)
        
        best_idx = closest_idx
        best_dist = dist_to_waypoint
        
        for i in range(start_idx, end_idx + 1):
            dist = np.linalg.norm([x - self.waypoints_x[i], y - self.waypoints_y[i]])
            if dist < best_dist:
                best_dist = dist
                best_idx = i
        
        # Ensure we are moving forward in the waypoint list, but not jumping too far ahead
        if best_dist < region_of_acceptance:
            if best_idx - self.last_waypoint_index < max_idx_jump:
                self.last_waypoint_index = max(self.last_waypoint_index, best_idx)
            else:
                self.last_waypoint_index = max(self.last_waypoint_index, self.last_waypoint_index + 1)
        else:
            self.last_waypoint_index = max(self.last_waypoint_index, self.last_waypoint_index + 1)
        
        target_idx = max(self.last_waypoint_index, best_idx)
        return min(target_idx, len(self.waypoints_x) - 1)